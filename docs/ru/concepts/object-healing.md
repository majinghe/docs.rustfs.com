---
title: "Проверка объектов и автоматическое восстановление"
description: "Описание функции самовосстановления объектов в RustFS в архитектуре один сервер–много дисков: назначение, принципы,流程,配置 и故障排查."
---

# Проверка объектов и автоматическое восстановление

## Обзор

## Архитектура RustFS и дизайн самовосстановления

### Архитектура один сервер – много дисков

RustFS использует дизайн одного сервера с множеством дисков, объединяя диски в общий логический пул, чтобы предоставить сервис объектного хранилища. При записи каждый объект разбивается на несколько фрагментов данных (shards) и избыточные фрагменты, которые распределяются по разным дискам для повышения надежности и производительности.

### Принципы дизайна самовосстановления

1. Проверка целостности данных: комбинирование контрольных сумм (checksum) для обеспечения一致ности данных фрагментов при чтении. Например, ZFS проверяет checksum каждого блока при чтении и выполняет восстановление при сбое проверки.
2. Избыточность и стирающее кодирование: с помощью erasure coding генерируются избыточные фрагменты. При потере или повреждении части фрагментов исходный объект восстанавливается из избыточных данных.
3. Многоуровневое срабатывание: онлайн-восстановление при чтении, фоновое сканирование и ручной запуск, чтобы сбалансировать производительность и надежность.

## Принципы самовосстановления объектов

### Проверка и стирающее кодирование

На этапе записи RustFS разбивает объект на k фрагментов данных и m избыточных фрагментов, распределяя их по n=k+m устройствам согласно заданным параметрам EC. При чтении, если обнаруживается повреждение или потеря фрагмента, восстановление выполняется из оставшихся корректных фрагментов.

### Проверка данных и ремонт (Scrub & Repair)

RustFS периодически выполняет легкую проверку (light scrub) и глубокую проверку (deep scrub) над пулом хранения:
- Легкая проверка: сравнение метаданных объекта и размеров фрагментов, оперативная маркировка повреждений.
- Глубокая проверка: побитовое чтение и проверка checksum, выявление и ремонт скрытых bad blocks или bit rot.

При обнаружении несоответствий RustFS автоматически запускает процесс Repair, восстанавливая поврежденные фрагменты из избыточных и записывая их обратно на исходный либо резервный диск, чтобы обеспечить исправность данных при следующем доступе.

## Процессы самовосстановления

### Онлайн-восстановление при чтении

При каждом `GET` или `HEAD` запросе клиентом RustFS вначале проверяет все фрагменты данных соответствующего объекта:
1. Если все фрагменты в порядке — возвращаются данные напрямую.
2. Если есть потерянные/поврежденные фрагменты — система восстанавливает недостающие части из избыточных и возвращает клиенту целый объект.
Эта схема, аналогичная чтению-с-восстановлением в MinIO, прозрачно исправляет ошибки без ущерба для запроса клиента.

### Фоновое сканирование и восстановление

Встроенный сканер объектов RustFS хешированно обходит 1/1024 объектов в пуле хранения для проверки целостности:
- Регулярно (настраиваемая частота) выполняет легкую проверку;
- При обнаружении повреждений немедленно инициирует процесс восстановления.
По умолчанию глубокая проверка на bit rot отключена для снижения накладных расходов; при необходимости ее можно включить.

### Ручной запуск восстановления

Администратор может запустить полнообъемное восстановление с помощью CLI:

```bash
rc admin heal start --all
```

Операция сканирует весь пул хранения и выполняет полную проверку и ремонт всех объектов; ресурсозатратно, рекомендуется выполнять в непиковое время.

## Примеры использования

```bash
# Просмотр текущего статуса самовосстановления
rc admin heal status
# Запуск восстановления для указанного bucket
rc admin heal start --bucket photos
# Остановка текущей задачи восстановления
rc admin heal stop
```

## Итоги

Самовосстановление объектов в RustFS объединяет зрелые решения MinIO, Ceph и ZFS. За счет многоуровневого триггера проверки и восстановления RustFS эффективно противостоит повреждению фрагментов, отказам дисков и bit rot как в одноузловой многодисковой, так и многосерверной архитектуре, обеспечивая высокую надежность и доступность объектного хранилища.

