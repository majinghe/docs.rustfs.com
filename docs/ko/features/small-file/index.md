# 소파일 최적화

> 초고성능 워크로드를 위한 메모리 객체 저장소 생성

서버 DRAM을 활용하여 대량의 IOPS와 처리량 성능이 필요한 워크로드를 위한 분산 공유 메모리 풀을 생성합니다.

## 배경

RustFS 소파일 최적화는 IOPS와 처리량 성능이 필요한 워크로드에 매우 적합합니다. 현대 아키텍처에서 이는 점점 더 AI/ML 워크로드를 의미합니다. 캐시가 없는 경우 I/O가 GPU의 병목이 될 수 있습니다.

엔터프라이즈 캐시를 사용하면 훈련, 검증 및 테스트 데이터 세트를 포함하는 저장소 버킷을 메모리에 저장하여 제공할 수 있습니다.

## 특징

### 🗃️ 전용 객체 캐시

RustFS 소파일 최적화는 파일 객체를 캐싱하는 데 특화되어 있습니다.
기존 객체 캐시에서 특정 객체를 찾을 수 없는 경우, 자동으로 해당 객체를 검색하고, 향후 요청을 위해 캐싱하며, 해당 객체를 호출자에게 반환합니다.

### 💾 일관성 해싱 알고리즘

RustFS의 소파일 최적화는 콘텐츠를 우선시합니다.
일관성 해싱 알고리즘을 사용하여 캐시된 객체 데이터를 캐시 노드 클러스터(피어 노드라고 함)에 분산시킵니다. 일관성 해싱은 객체의 키를 기반으로 객체를 쉽게 찾을 수 있도록 보장합니다. 이는 객체의 키 값과 캐시된 객체를 저장하는 노드 간에 일대일 관계를 생성합니다. 또한 노드가 동일한 양의 데이터를 포함하도록 보장하여 한 노드가 과부하되고 다른 노드가 유휴 상태가 되는 상황이 발생하지 않습니다. 그러나 더 중요한 것은 객체를 추가하거나 노드를 제거할 때 시스템을 정렬하기 위해 최소한의 재구성이 필요하도록 객체를 분산시키는 방식입니다.

### 🧹 롤링 캐시 메모리 관리

RustFS 롤링 캐시는 메모리 관리에 사용됩니다. RustFS는 롤링 캐시를 사용하여 캐시의 총 크기를 소파일 최적화 구성에서 지정된 제한 내에서 유지합니다. 새 객체를 추가하면 캐시 크기가 지정된 제한을 초과하는 경우, 해당 객체가 마지막으로 요청된 시간을 나타내는 타임스탬프를 기반으로 하나 이상의 객체가 삭제됩니다.

### 🔄 자동 버전 업데이트

새 객체 버전을 자동으로 업데이트합니다. 캐시된 객체가 업데이트된 경우 RustFS 객체 저장소는 자동으로 새 객체 버전으로 캐시를 업데이트합니다.

### 🧩 원활한 API 통합

RustFS 소파일 최적화는 RustFS의 백그라운드 확장입니다. 소파일 최적화가 RustFS의 확장이므로 개발자는 새로운 API를 학습할 필요가 없습니다. 개발자는 이전과 동일한 API를 사용합니다. 요청된 객체가 캐시에 있는 경우 RustFS는 자동으로 캐시에서 가져옵니다. 특정 객체가 캐시되어야 하고 처음 요청되는 경우 RustFS는 객체 저장소에서 가져와 호출자에게 반환하고 후속 요청을 위해 캐시에 배치합니다.
