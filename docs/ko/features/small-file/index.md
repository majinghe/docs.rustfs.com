---
title: "소파일 최적화"
description: "초고성능 워크로드를 위한 메모리 객체 스토리지 생성"
---

# 소파일 최적화

> 초고성능 워크로드를 위한 메모리 객체 스토리지 생성

대량의 IOPS와 처리량 성능이 필요한 워크로드를 위해 서버 DRAM을 활용하여 분산 공유 메모리 풀을 생성합니다.

## 배경

RustFS 소파일 최적화는 IOPS와 처리량 성능을 요구하는 워크로드에 이상적입니다. 현대 아키텍처에서 이는 점점 더 AI/ML 워크로드를 의미합니다. 캐시 없이는 I/O가 GPU의 병목이 될 수 있습니다.

엔터프라이즈 캐시를 사용하여 훈련, 검증, 테스트 데이터셋을 포함한 버킷을 메모리에 유지하여 기반 성능을 제공할 수 있습니다.

## 기능

### 🗃️ 전용 객체 캐시

RustFS 소파일 최적화는 파일 객체 캐싱을 위해 특별히 설계되었습니다.
기존 객체 캐시에서 객체를 찾을 수 없는 경우, 자동으로 객체를 검색하고, 향후 요청을 위해 캐시하고, 객체를 호출자에게 반환합니다.

### 💾 일관된 해시 알고리즘

RustFS의 소파일 최적화는 콘텐츠를 우선시합니다.
일관된 해시 알고리즘을 사용하여 캐시된 객체 데이터를 캐시 노드 클러스터(피어라고 함)에 분산시킵니다. 일관된 해시는 객체의 키를 기반으로 객체를 쉽게 찾을 수 있도록 보장합니다. 이는 객체의 키 값과 캐시된 객체를 보유한 노드 간에 일대일 관계를 만듭니다. 또한 노드가 동일한 양의 데이터를 포함하도록 보장하여, 다른 노드는 유휴 상태로 남아있는 동안 하나의 노드가 과부하가 걸리는 것을 방지합니다. 더 중요한 것은, 노드가 추가되거나 제거될 때 시스템을 정렬하기 위해 최소한의 재설정만 필요하도록 객체를 분산시킵니다.

### 🧹 롤링 캐시 메모리 관리

RustFS는 메모리 관리를 위해 롤링 캐시를 사용합니다. RustFS는 롤링 캐시를 사용하여 소파일 최적화 구성에서 지정된 제한 내에서 전체 캐시 크기를 유지합니다. 새 객체를 추가하면 캐시 크기가 지정된 제한을 초과할 경우, 객체가 마지막으로 요청된 시간을 나타내는 타임스탬프를 기반으로 하나 이상의 객체가 제거됩니다.

### 🔄 자동 버전 업데이트

새로운 객체 버전을 자동으로 업데이트합니다. 캐시된 객체가 업데이트된 경우, RustFS 객체 스토리지는 자동으로 새로운 객체 버전으로 캐시를 업데이트합니다.

### 🧩 매끄러운 API 통합

RustFS 소파일 최적화는 RustFS의 백그라운드 확장 기능입니다. 소파일 최적화가 RustFS의 확장 기능이기 때문에 개발자들은 새로운 API를 배울 필요가 없습니다. 개발자들은 이전과 동일한 API를 사용합니다. 요청된 객체가 캐시에 있는 경우, RustFS는 자동으로 캐시에서 가져옵니다. 객체가 캐시되어야 하고 처음 요청되는 경우, RustFS는 객체 스토리지에서 가져와서 호출자에게 반환하고, 이후 요청을 위해 캐시에 배치합니다.

